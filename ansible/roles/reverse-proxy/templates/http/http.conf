http {
  # If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the
  # scheme used to connect to this server
  map $http_x_forwarded_proto $proxy_x_forwarded_proto {
      default $http_x_forwarded_proto;
      ''      $scheme;
  }
  # If we receive X-Forwarded-Port, pass it through; otherwise, pass along the
  # server port the client connected to
  map $http_x_forwarded_port $proxy_x_forwarded_port {
      default $http_x_forwarded_port;
      ''      $server_port;
  }
  # If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
  # Connection header that may have been passed to this server
  map $http_upgrade $proxy_connection {
      default upgrade;
      '' close;
  }
  # Apply fix for very long server names
  server_names_hash_bucket_size 128;
  # Set appropriate X-Forwarded-Ssl header
  map $scheme $proxy_x_forwarded_ssl {
      default off;
      https on;
  }

  charset                 utf-8;
  sendfile                on;
  #tcp_nopush             on;
  tcp_nodelay             on;
  log_not_found           off;
  types_hash_max_size     2048;
  types_hash_bucket_size  64;
  client_max_body_size    16M;

  # MIME
  include                 mime.types;
  default_type            application/octet-stream;

  # Logging
  # log_format              main  '$remote_addr - $remote_user [$time_local] "$request" '
  #                               '$status $body_bytes_sent "$http_referer" '
  #                               '"$http_user_agent" "$http_x_forwarded_for"';
  # log_format              vhost '$host $remote_addr - $remote_user [$time_local] '
  #                               '"$request" $status $body_bytes_sent '
  #                               '"$http_referer" "$http_user_agent"';
  # access_log              /var/log/nginx/access.log main;
  access_log              /var/log/nginx/access.log;
  error_log               /var/log/nginx/error.log warn;

  # Limits
  limit_req_log_level     warn;
  limit_req_zone          $binary_remote_addr zone=login:10m rate=10r/m;

  # SSL
  ssl_dhparam             /etc/nginx/dhparam/dhparam.pem;
  ssl_session_timeout     1d;
  ssl_session_cache       shared:SSL:10m;
  ssl_session_tickets     off;

  # Mozilla Modern configuration
  ssl_protocols           {% for ssl_protocol in nginx.config.http.ssl_protocols | default(default_nginx.config.http.ssl_protocols) %}{{ ssl_protocol }}{% if not loop.last %} {% endif %}{% endfor %};
  # Comment for now because TLSv1.3 only triggers an error when specifying the protocols. It use another API than the one with TLS1.2
  # ssl_ciphers {% for ssl_cipher in nginx.config.http.ssl_ciphers %}{{ ssl_cipher }}{% if not loop.last %}:{% endif %}{% endfor %};
  ssl_prefer_server_ciphers {{ nginx.config.http.ssl_prefer_server_ciphers | default(default_nginx.config.http.ssl_prefer_server_ciphers) }};

  # OCSP Stapling
  # TODO: add self-signed certificate CA to CA directory
  # ssl_stapling            on;
  # ssl_stapling_verify     on;
  resolver                {% for resolv in nginx.dns_resolver %}{{ resolv }}{% if not loop.last %} {% endif %}{% endfor %} valid=28800s ipv6=off;
  resolver_timeout        1s;

  # Security
  # Disables emitting nginx version in error messages and in the “Server” response header field.
  server_tokens           off;

  # Load configs
  include /etc/nginx/conf.d/*.conf;

  # gzip
  gzip              on;
  gzip_vary         on;
  gzip_proxied      any;
  gzip_comp_level   6;
  gzip_types        text/plain text/css text/xml application/xml application/json application/javascript application/x-javascript text/javascript application/rss+xml application/atom+xml image/svg+xml;
  gzip_disable      "msie6";

  # HTTP 1.1 support
  proxy_http_version 1.1;
  proxy_buffering off;

  # Proxy headers
  proxy_set_header Host               $http_host;
  proxy_set_header Upgrade            $http_upgrade;
  proxy_set_header Connection         $proxy_connection;
  proxy_set_header X-Real-IP          $remote_addr;
  proxy_set_header X-Forwarded-For    $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto  $proxy_x_forwarded_proto;
  proxy_set_header X-Forwarded-Ssl    $proxy_x_forwarded_ssl;
  # proxy_set_header X-Forwarded-Host   $http_host;
  proxy_set_header X-Forwarded-Port   $proxy_x_forwarded_port;
  # Mitigate httpoxy attack
  proxy_set_header Proxy "";

  # Proxy timeouts
  proxy_connect_timeout               30s;
  proxy_send_timeout                  30s;
  proxy_read_timeout                  30s;

  # Others
  keepalive_timeout  35;

{% if nginx.config.http.cache is defined %}
  proxy_cache_path {{ nginx.config.http.cache.path }}  keys_zone={{ nginx.config.http.cache.name | default('pouet', true) }}:10m{% if nginx.config.http.cache.size is defined %}max_size={{ nginx.config.http.cache.size }}{% endif %} use_temp_path=off;
{% endif %}

{% if nginx.config.http.geo is defined %}
{%  set geo = nginx.config.http.geo %}
{%  filter indent(width=2) %}
{%    include 'http/geo.conf' %}
{%  endfilter %}
{% endif %}

  server {
    listen 80;
    server_name _; # This is just an invalid value which will never trigger on a real hostname.

    # access_log /var/log/nginx/access.log;
    access_log /var/log/nginx/access.log;

    return 503;
  }
  server {
    listen 443 ssl http2;
    # listen 443 http3 reuseport;
    server_name _; # This is just an invalid value which will never trigger on a real hostname.

    # access_log /var/log/nginx/access.log;
    access_log /var/log/nginx/access.log;

    ssl_certificate /etc/nginx/certs/localhost/localhost.crt;
    ssl_certificate_key /etc/nginx/certs/localhost/localhost.key;

    return 503;
  }

{% if nginx.http.upstreams is defined %}
{%  set upstreams = nginx.http.upstreams %}
{%  filter indent(width=2) %}
{%    include 'common/upstream.conf' %}
{%  endfilter %}
{% endif %}

{% if nginx.http.services is defined %}
{%  set services = nginx.http.services %}
{%  filter indent(width=2) %}
{%    include 'http/services.conf' %}
{%  endfilter %}
{% endif %}
}