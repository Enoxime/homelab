user  {{ generic_web_server.config.user | default(default_nginx.config.user) }};
worker_processes auto;
worker_rlimit_nofile 65535;

error_log   /var/log/nginx/error.log warn;
pid         /run/nginx.pid;

# Load modules
include     /etc/nginx/modules-enabled/*.conf;

events {
  multi_accept        on;
  worker_connections  65535;
}

http {
  # Apply fix for very long server names
  server_names_hash_bucket_size 128;

  charset                 utf-8;
  sendfile                on;
  #tcp_nopush             on;
  tcp_nodelay             on;
  log_not_found           off;
  types_hash_max_size     2048;
  types_hash_bucket_size  64;
  client_max_body_size    16M;

  # MIME
  include                 mime.types;
  default_type            application/octet-stream;

  # Logging
  # log_format              main  '$remote_addr - $remote_user [$time_local] "$request" '
  #                               '$status $body_bytes_sent "$http_referer" '
  #                               '"$http_user_agent" "$http_x_forwarded_for"';
  # log_format              vhost '$host $remote_addr - $remote_user [$time_local] '
  #                               '"$request" $status $body_bytes_sent '
  #                               '"$http_referer" "$http_user_agent"';
  # access_log              /var/log/nginx/access.log main;
  access_log              /var/log/nginx/access.log;
  error_log               /var/log/nginx/error.log warn;

  # Limits
  limit_req_log_level     warn;
  limit_req_zone          $binary_remote_addr zone=login:10m rate=10r/m;

  # SSL
  ssl_dhparam             /etc/nginx/dhparam/dhparam.pem;
  ssl_session_timeout     1d;
  ssl_session_cache       shared:SSL:10m;
  ssl_session_tickets     off;

  # Mozilla Modern configuration
  ssl_protocols           {% for ssl_protocol in generic_web_server.config.http.ssl_protocols | default(default_nginx.config.http.ssl_protocols) %}{{ ssl_protocol }}{% if not loop.last %} {% endif %}{% endfor %};
  # Comment for now because TLSv1.3 only triggers an error when specifying the protocols. It use another API than the one with TLS1.2
  # ssl_ciphers {% for ssl_cipher in generic_web_server.config.http.ssl_ciphers %}{{ ssl_cipher }}{% if not loop.last %}:{% endif %}{% endfor %};
  ssl_prefer_server_ciphers {{ generic_web_server.config.http.ssl_prefer_server_ciphers | default(default_nginx.config.http.ssl_prefer_server_ciphers) }};

  # OCSP Stapling
  # TODO: add self-signed certificate CA to CA directory
  # ssl_stapling            on;
  # ssl_stapling_verify     on;
  resolver                {% for resolv in generic_web_server.dns_resolver %}{{ resolv }}{% if not loop.last %} {% endif %}{% endfor %} valid=28800s ipv6=off;
  resolver_timeout        1s;

  # Security
  # Disables emitting nginx version in error messages and in the “Server” response header field.
  server_tokens           off;

  # Load configs
  include /etc/nginx/conf.d/*.conf;

  # gzip
  gzip              on;
  gzip_vary         on;
  gzip_proxied      any;
  gzip_comp_level   6;
  gzip_types        text/plain text/css text/xml application/xml application/json application/javascript application/x-javascript text/javascript application/rss+xml application/atom+xml image/svg+xml;
  gzip_disable      "msie6";

  # Others
  keepalive_timeout  35;

  server {
    listen 80;
    server_name _; # This is just an invalid value which will never trigger on a real hostname.

    # access_log /var/log/nginx/access.log;
    access_log /var/log/nginx/access.log;

    return 503;
  }
  server {
    listen 443 ssl http2;
    # listen 443 http3 reuseport;
    server_name _; # This is just an invalid value which will never trigger on a real hostname.

    # access_log /var/log/nginx/access.log;
    access_log /var/log/nginx/access.log;

    ssl_certificate /etc/nginx/certs/localhost/localhost.crt;
    ssl_certificate_key /etc/nginx/certs/localhost/localhost.key;

    return 503;
  }

{% for service in generic_web_server.services %}

  ### {{ service.name }}'s http config
  server {
    # TODO: Add proxy_cache, proxy_cache_use_stale and more caching options
    listen {% if service.listen is defined %}{{ service.listen }}:{% endif %}80;
    server_name {{ service.main_domain_name }}{% if service.domain_names is defined %} {% for domain in service.domain_names %}{{ domain }}{% if not loop.last %} {% endif %}{% endfor %}{% endif %};

    location / {
        return 301 https://$host$request_uri;
    }
  }

  ### {{ service.name }}'s https config
  server {
    listen {% if service.listen is defined %}{{ service.listen }}:{% endif %}443 ssl http2;
    # listen 443 http3 reuseport;
    server_name {{ service.main_domain_name }}{% if service.domain_names is defined %} {% for domain in service.domain_names %}{{ domain }}{% if not loop.last %} {% endif %}{% endfor %}{% endif %};

    # logging
    # access_log /var/log/nginx/access.log;
    access_log /var/log/nginx/access.log;
  {%  if service.ssl is defined %}
  {%    if service.ssl.type == "manual" %}


    # Certificate config
  {%      if service.ssl.cert_name is defined %}

    ssl_certificate /etc/nginx/certs/{{ service.ssl.cert_name }}/{{ service.ssl.cert_name }}.bundle.crt;
    ssl_certificate_key /etc/nginx/certs/{{ service.ssl.cert_name }}/{{ service.ssl.cert_name }}.key;
  {%      endif %}
  {%    elif service.ssl.type == "letsencrypt" %}
  {%      for lets in letsencrypt_cert_exists.results %}
  {%        if lets.service.name == service.name and lets.stat.exists %}

    ssl_certificate /etc/letsencrypt/live/{{ service.main_domain_name }}/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/{{ service.main_domain_name }}/privkey.pem;
  {%        endif %}
  {%      endfor %}
  {%    endif %}
  {%  endif %}

    # TODO: Setup security headers
    # # security headers
    # add_header X-Frame-Options           "SAMEORIGIN" always;
    # add_header X-XSS-Protection          "1; mode=block" always;
    # add_header X-Content-Type-Options    "nosniff" always;
    # add_header Referrer-Policy           "no-referrer-when-downgrade" always;
    # add_header Content-Security-Policy   "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;
    # add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;

    # TODO: Create a dhparam for each vhosts

    add_header Strict-Transport-Security "max-age=15552000" always; # Three months
  {%  if service.unauthorized_method is defined %}

    # restrict methods
    # if ($request_method !~ ^(GET|POST|PUT|DELETE)$) {
    #     return '405';
    # }
    if ($request_method !~ ^({% for method in service.unauthorized_method %}{{ method }}{% if not loop.last %}|{% endif %}{% endfor %})$) {
      return '405';
    }
  {%  endif %}

    root /var/www/{{ service.name }};

    location / {
      index index.html;
    }
  }
{% endfor %}
}